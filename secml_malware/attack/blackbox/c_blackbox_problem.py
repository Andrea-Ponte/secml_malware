from abc import abstractmethod
from secml.array import CArray
from secml_malware.attack.blackbox.c_wrapper_phi import CWrapperPhi
import numpy as np


class CBlackBoxProblem:
	def __init__(
			self,
			model_wrapper: CWrapperPhi,
			latent_space_size: int,
			population_size: int,
			penalty_regularizer: float,
			iterations: int,
			seed: int = None,
			is_debug: bool = False
	):
		self.model_wrapper = model_wrapper
		self.latent_space_size = latent_space_size
		self.population_size = population_size
		self._original_x = None
		self.penalty_regularizer = penalty_regularizer
		self.iterations = iterations
		self.seed = seed
		self.is_debug = is_debug

		self.confidences_ = []
		self.fitness_ = []

	@abstractmethod
	def init_starting_point(self, x: CArray):
		raise NotImplementedError("This class is abstract, you should implement this function!")

	@abstractmethod
	def get_bounds(self):
		raise NotImplementedError("This class is abstract, you should implement this function!")

	def fitness(self, t):
		candidate = self.apply_feasible_manipulations(t, self._original_x)
		penalty_term = self.compute_penalty_term(self._original_x, candidate, self.penalty_regularizer)
		score = self.score_step(candidate, penalty_term)
		return [score]

	def score_step(self, x: CArray, penalty_term: float) -> float:
		_, confidence = self.model_wrapper.predict(x, return_decision_function=True)
		confidence = confidence[0, 1].item()
		self.confidences_.append(confidence)
		fitness_value = confidence + penalty_term
		self.fitness_.append(fitness_value)
		return fitness_value

	def export_internal_results(self):
		confidence = self._slice_sequence(self.population_size, self.confidences_)
		fitness = self._slice_sequence(self.population_size, self.fitness_)
		best_idx = np.argmin(fitness, axis=1)
		fitness = [f[i] for f, i in zip(fitness, best_idx)]
		confidence = [f[i] for f, i in zip(confidence, best_idx)]
		return confidence, fitness

	def _slice_sequence(self, slice_size, sequence):
		how_many = len(sequence) // slice_size
		expanded_sequence = [
			sequence[0:slice_size] + sequence[i * slice_size: (i + 1) * slice_size]
			for i in range(how_many)
		]
		expanded_sequence = np.array(expanded_sequence)
		return expanded_sequence

	def compute_penalty_term(self, original_x : CArray, adv_x :CArray, par: float) -> float:
		return par * abs(adv_x.shape[-1] - original_x.shape[-1])

	@abstractmethod
	def apply_feasible_manipulations(self, t, x: CArray) -> CArray:
		raise NotImplementedError("This method is abstract, you should implement it somewhere else!")
