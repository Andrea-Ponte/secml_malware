from abc import abstractmethod
from secml.array import CArray
from secml_malware.attack.blackbox.c_wrapper_phi import CWrapperPhi


class CBlackBoxProblem:
	def __init__(
			self,
			model_wrapper: CWrapperPhi,
			latent_space_size: int,
			population_size : int,
			penalty_regularizer : float,
			iterations : int,
			seed : int = None,
			is_debug : bool = False
	):
		self.model_wrapper = model_wrapper
		self.latent_space_size = latent_space_size
		self.population_size = population_size
		self._original_x = None
		self.penalty_regularizer = penalty_regularizer
		self.iterations = iterations
		self.seed = seed
		self.is_debug = is_debug

	@abstractmethod
	def init_starting_point(self, x : CArray):
		raise NotImplementedError("This class is abstract, you should implement this function!")

	@abstractmethod
	def get_bounds(self):
		raise NotImplementedError("This class is abstract, you should implement this function!")

	def fitness(self, t):
		candidate = self.apply_feasible_manipulations(t, self._original_x)
		penalty_term = self.compute_penalty_term(self._original_x, candidate, self.penalty_regularizer)
		score = self.score_step(candidate, penalty_term)
		return [score]

	def score_step(self, x : CArray, penalty_term: float) -> float:
		_, confidence = self.model_wrapper.predict(x, return_decision_function=True)
		confidence = confidence[0, 1].item()
		return confidence + penalty_term

	@abstractmethod
	def compute_penalty_term(self, original_x : CArray, adv_x :CArray, par: float) -> float:
		raise NotImplementedError("This method is abstract, you should implement it somewhere else!")

	@abstractmethod
	def apply_feasible_manipulations(self, t, x : CArray) -> CArray:
		raise NotImplementedError("This method is abstract, you should implement it somewhere else!")

