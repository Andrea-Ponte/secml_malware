"""
.. module:: CGreedyEvasion
	:synopsis: Class performs greedy evasion attack agasint classifier by altering bytes just looking at the score

.. moduleauthor:: Luca Demetrio <luca.demetrio@dibris.unige.it>

"""

import copy
from secml_malware.attack import CMalConvEvasion


class CGreedyEvasion(CMalConvEvasion):
	"""Greedy attack base class.
	It implements the method for computing the best byte for a particular location.
	"""

	def __init__(
		self,
		classifier,
		surrogate_data,
		index_to_perturb,
		how_many=None,
		surrogate_classifier=None,
		use_surrogate=False,
		iterations=100.0,
		is_debug=False,
		random_init=False,
	):
		"""Class constructor.

		Arguments:
			classifier {CClassifierMalConvPyTorch} -- The classifier to evade
			surrogate_data {CDataset} -- data used for the surrogate (if any)
			index_to_perturb {list of int} -- Indexes that will be used for the attack.

		Keyword Arguments:
			how_many {int} -- How many index to perturb. None means use all indexes (default: {None})
			surrogate_classifier {CClassifierMalConvPyTorch} -- Surrogate classifier, if any (default: {None})
			use_surrogate {bool} -- Specify if should use the surrogate instead of real classifier (default: {False})
			iterations {float} -- How many iterations for the attack (default: {100.0})
			is_debug {bool} -- If true, it will print on console additional information duringthe attack (default: {False})
			random_init {bool} -- Randomize the bytes located at the specified indexes before starting the attack(default: {False})

		Returns:
			CGreedyEvasion -- the evasion object
		"""
		super(CGreedyEvasion, self).__init__(
			classifier,
			index_to_perturb,
			len(index_to_perturb) if how_many is None else how_many,
			surrogate_data,
			surrogate_classifier=surrogate_classifier,
			use_surrogate=use_surrogate,
			iterations=iterations,
			is_debug=is_debug,
			random_init=random_init,
		)

	def _run(self, x0, y0, x_init=None):
		self._init_internal_solver(x0)
		self.confidences_ = []
		t = self._iterations
		predict_fun = self._get_predict_function()
		if x_init is not None:
			x_adv = x_init
		else:
			x_adv = copy.copy(x0)
		_, current_conf = predict_fun(x_adv, return_decision_function=True)
		current_conf = current_conf[1].item()
		indexes_to_use = self.indexes_to_perturb[: self._how_many]
		while t and current_conf > 0.5:
			t = t - 1
			for i in indexes_to_use:
				confidences = []
				x_t = copy.copy(x_adv)
				for j in range(256):
					x_t[i] = j
					_, confidence = predict_fun(x_t, return_decision_function=True)
					confidence = confidence[1].item()
					confidences.append(confidence)
				lowest_index = sorted(
					range(len(confidences)), key=confidences.__getitem__
				)[0]
				self.confidences_.append(confidences[lowest_index])
				print(
					"#>Iteration {}-th: {}".format(
						self._iterations - t, confidences[lowest_index]
					)
				)
				x_adv[i] = lowest_index
				current_conf = confidences[lowest_index]
		return x_init, current_conf
