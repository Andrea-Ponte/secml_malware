import numpy as np

from secml_malware.attack.c_fast_gradient_sign_evasion import CFastGradientSignMethodEvasion
from secml_malware.models import CClassifierEnd2EndMalware


class CKreukEvasion(CFastGradientSignMethodEvasion):
	def __init__(
			self,
			end2end_model: CClassifierEnd2EndMalware,
			how_many_padding_bytes : int,
			epsilon: float,
			iterations: int = 100,
			is_debug: bool = False,
			threshold: float = 0.5,
			invalid_byte_value: int = -1,
			p_norm : float = np.infty
	):
		super(CKreukEvasion, self).__init__(
			end2end_model=end2end_model,
			indexes_to_perturb=[],
			epsilon=epsilon,
			iterations=iterations,
			is_debug=is_debug,
			threshold=threshold,
			penalty_regularizer=0,
			invalid_byte_value=invalid_byte_value,
			p_norm=p_norm,
		)
		self.how_many_padding_bytes = how_many_padding_bytes

	def _run(self, x0, y0, x_init=None):
		invalid_value = 256 if self.invalid_pos == -1 else self.invalid_pos
		padding_positions = x0.find(x0 == invalid_value)
		if not padding_positions:
			self.indexes_to_perturb = []
		else:
			self.indexes_to_perturb = list(
				range(
					padding_positions[0],
					min(x0.size, padding_positions[0] + self.how_many_padding_bytes),
				)
			)
		return super(CFastGradientSignMethodEvasion, self)._run(x0, y0, x_init=x_init)
