import math

import numpy
from secml.array import CArray
from secml_malware.attack.c_discretized_bytes_evasion import CDiscreteBytesEvasion
from secml_malware.models import CClassifierEnd2EndMalware, End2EndModel
import torch

from secml_malware.utils import extend_pe


class CFormatExploitEvasion(CDiscreteBytesEvasion):

	def __init__(self,
			end2end_model : CClassifierEnd2EndMalware,
			preferable_extension_amount : int = 0x200,
			pe_header_extension : int = 0x200,
			iterations : int =100,
			is_debug: bool = False,
			random_init: bool = False,
			threshold: float = 0.5,
			penalty_regularizer: float = 0,
			invalid_byte_value: int = -1,
	):
		super(CFormatExploitEvasion, self).__init__(
			end2end_model=end2end_model,
			index_to_perturb=[],
			iterations=iterations,
			is_debug=is_debug,
			random_init=random_init,
			threshold=threshold,
			penalty_regularizer=penalty_regularizer,
			invalid_byte_value=invalid_byte_value
		)
		self.preferable_extension_amount = preferable_extension_amount
		self.pe_header_extension = pe_header_extension

	def _shift_sections_by_amount(self, x : list, pe_shifted_by : int = 0):
		if not self.preferable_extension_amount:
			return x, []
		return extend_pe.shift_section_by(x, self.preferable_extension_amount, pe_shifted_by)

	def _shift_pe_header(self, x : list):
		if not self.pe_header_extension:
			return x, []
		return extend_pe.shift_pe_header_by(x, self.pe_header_extension)

	def _run(self, x0, y0, x_init=None):
		x_init, _ = self._craft_perturbed_c_array(x0)
		return super(CFormatExploitEvasion, self)._run(x0, y0, x_init)

	def _craft_perturbed_c_array(self, x0 : CArray):
		x_init = self._generate_list_adv_example(x0)
		x_init = CArray(torch.tensor(
			[End2EndModel.list_to_numpy(
				x_init,
				self.classifier.get_input_max_length(),
				self.classifier.get_embedding_value(),
				self.classifier.get_is_shifting_values())])
						.long()
						)
		return x_init, self.indexes_to_perturb

	def _generate_list_adv_example(self, x0):
		x_init = self.create_int_list_from_x_adv(x0)
		x_init, index_to_perturb_sections = self._shift_sections_by_amount(x_init)
		x_init, index_to_perturb_pe = self._shift_pe_header(x_init)
		if self.is_debug:
			print(f'> {len(index_to_perturb_pe)} for PE shift')
			print(f'> {len(index_to_perturb_sections)} for Section shift')
		self.indexes_to_perturb = index_to_perturb_pe + [i + len(index_to_perturb_pe) for i in
														 index_to_perturb_sections]
		return x_init, self.indexes_to_perturb

	def create_real_sample_from_adv(self, original_file_path : str, x_adv : CArray, new_file_path : str = None):
		with open(original_file_path, 'rb') as f:
			code = bytearray(f.read())
		original_x = CArray([numpy.frombuffer(code, dtype=numpy.uint8).astype(numpy.uint16)])
		if self.classifier.get_is_shifting_values():
			original_x += self.classifier.get_is_shifting_values()
		x_init, index_to_perturb = self._generate_list_adv_example(original_x)
		x_init = CArray([x_init])
		x_init[0, index_to_perturb] = x_adv[0, index_to_perturb]
		x_real = x_init[0,:].tolist()[0]
		x_real_adv = b''.join([bytes([i]) for i in x_real])
		if new_file_path:
			with open(new_file_path, 'wb') as f:
				f.write(x_real_adv)
		return x_real_adv