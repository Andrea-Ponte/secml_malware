"""
.. module:: MalConv transfer attack
	:synopsis: MalConv transfer attack

.. moduleauthor:: Luca Demetrio <luca.demetrio@dibris.unige.it>
"""
import torch

from secml.data import CDataset
from secml_malware.attack import CPaddingMalconvEvasion, CHeaderMalConvEvasion
from secml_malware.utils.malconv_test_base import MalConvBaseTests


class MalConvTransferAttacksTest(MalConvBaseTests):

	def setUp(self):
		super(MalConvTransferAttacksTest, self).setUp()
		self.classifier.load_pretrained_model(self.ember_path)
		with open(self.surrogate_path, 'r') as f:
			self.surrogate_classifier.load_state(torch.load(f, map_location='cpu'))
		self.Y = self.classifier.predict(self.X, return_decision_function=False)
		self.dataset = CDataset(self.X, self.Y)

	def test_surrogate_transfer_header_attack_on_ember(self):
		seen_as_malware = sum(self.Y == 1)
		attack = CHeaderMalConvEvasion(self.classifier,  CDataset(self.X, self.Y), use_surrogate=True, is_debug=False, random_init=True)
		_, _, adv_ds, _ = attack.run(self.X[0], self.Y[0])
		transfer_x = self.X[1:, :]
		transfer_x[:, 2:59] = torch.Tensor(adv_ds.X[0, 2:59].tondarray())
		transfer_y = self.classifier.predict(transfer_x)
		self.assertLess(sum(transfer_y == 1), seen_as_malware - 1)

	def test_transfer_header_attack_on_ember(self):
		seen_as_malware = sum(self.Y == 1)
		attack = CHeaderMalConvEvasion(self.classifier, CDataset(self.X, self.Y), use_surrogate=False, is_debug=False, random_init=True)
		_, _, adv_ds, _ = attack.run(self.X[0], self.Y[0])
		transfer_x = self.X[1:, :]
		transfer_x[:, 2:59] = torch.Tensor(adv_ds.X[0, 2:59].tondarray())
		transfer_y = self.classifier.predict(transfer_x)
		self.assertLess(sum(transfer_y == 1), seen_as_malware - 1)

	def test_transfer_padding_attack_on_ember(self):
		seen_as_malware = sum(self.Y == 1)
		padding = 2000
		first_index = (self.X[0] == 256).nonzero()[0].item()
		attack = CPaddingMalconvEvasion(self.classifier, 1000, CDataset(self.X, self.Y), use_surrogate=True, is_debug=False, random_init=True)
		_, _, adv_ds, _ = attack.run(self.X[0], self.Y[0])
		payload = adv_ds.X[0, first_index : first_index + padding]
		transfer_x = self.X[1:, :]
		for i, x in enumerate(transfer_x):
			first_padding_index = (x == 256).nonzero()
			if not first_padding_index.nelement():
				continue
			first_padding_index = first_padding_index[0].item()
			upper_bound = min(first_padding_index + padding, len(x))
			transfer_x[i, first_padding_index : upper_bound] = torch.Tensor(payload[:min(padding, len(x) - first_padding_index)].tondarray())
		transfer_y = self.classifier.predict(transfer_x)
		self.assertLess(sum(transfer_y == 1), seen_as_malware - 1)
