"""
.. module:: MalConTestSuite
	:synopsis: MalConv basic unit tests

.. moduleauthor:: Luca Demetrio <luca.demetrio@dibris.unige.it>
"""

import unittest
import torch
from secml.array import CArray

from secml_malware.utils.malconv_test_base import MalConvBaseTests
from secml_malware.attack import CHeaderMalConvEvasion, CPaddingMalconvEvasion, CInterSectionEvasion, CGreedyEvasion
from secml.data import CDataset


class EvasionMalConvTestSuite(MalConvBaseTests):
	def setUp(self):
		super(EvasionMalConvTestSuite, self).setUp()
		self.classifier.load_pretrained_model(self.ember_path)
		self.surrogate_classifier.load_pretrained_model(self.surrogate_path)
		self.Y = self.classifier.predict(CArray(self.X), return_decision_function=False)

	def test_blackbox_surrogate_model_attack_random_init(self):
		attack = CHeaderMalConvEvasion(
			self.classifier,
			is_debug=False,
			random_init=True,
		)
		y_pred, _, _, _ = attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_whitebox_model_attack_header_greedy(self):
		attack = CGreedyEvasion(
			self.classifier,
			index_to_perturb=[i for i in range(2, 0x3c)],
			iterations=100,
			is_debug=False,
			random_init=True,
		)
		y_pred, _, _, _ = attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_whitebox_ember_model_attack_random_init(self):
		attack = CHeaderMalConvEvasion(
			self.classifier,
			is_debug=False,
			random_init=True,
		)
		y_pred, _, _, _ = attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_whitebox_ember_model_attack_no_random_init(self):
		attack = CHeaderMalConvEvasion(
			self.classifier,
			is_debug=False,
			random_init=False,
		)
		y_pred, scores, _, _ = attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_blackbox_surrogate_model_attack_no_random_init(self):
		attack = CHeaderMalConvEvasion(
			self.classifier,
			is_debug=False,
			random_init=False,
		)
		y_pred, _, _, _ = attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_append_whitebox_ember_model_attack(self):
		padding_attack = CPaddingMalconvEvasion(
			self.classifier,
			1000,
			random_init=True,
		)
		y_pred, _, _, _ = padding_attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_append_blackbox_ember_model_attack(self):
		padding_attack = CPaddingMalconvEvasion(
			self.classifier,
			1000,
			random_init=True,
		)
		y_pred, _, _, _ = padding_attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)

	def test_inter_sections_blackbox_ember_model_attack(self):
		padding_attack = CInterSectionEvasion(
			self.classifier,
			how_many=50,
			random_init=True,
		)
		y_pred, _, _, _ = padding_attack.run(self.X, self.Y)
		n_old_y_malw = sum(self.Y == 1)
		n_false_negative = sum(self.Y == 0)
		n_new_detected_malw = sum(y_pred == 1) - n_false_negative
		self.assertNotEqual(
			n_old_y_malw,
			n_new_detected_malw,
			msg="Evasion achieved: {}/{}".format(
				self.Y.shape[0] - n_new_detected_malw, self.Y.shape[0]
			),
		)


if __name__ == "__main__":
	unittest.main()
