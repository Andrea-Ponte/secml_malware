"""
Malware Detection by Eating a Whole EXE
Edward Raff, Jon Barker, Jared Sylvester, Robert Brandon, Bryan Catanzaro, Charles Nicholas
https://arxiv.org/abs/1710.09435
"""
from os.path import isfile
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from secml_malware.utils.exceptions import FileNotExistsException

from secml.settings import SECML_PYTORCH_USE_CUDA
use_cuda = torch.cuda.is_available() and SECML_PYTORCH_USE_CUDA


class MalConv(nn.Module):

	"""
	Architecture implementation.
	"""
	def __init__(self, pretrained_path=None):
		super(MalConv, self).__init__()
		self.embedding_1 = nn.Embedding(num_embeddings=257, embedding_dim=8)
		self.conv1d_1 = nn.Conv1d(in_channels=8, out_channels=128, kernel_size=(500,), stride=(500,), groups=1, bias=True)
		self.conv1d_2 = nn.Conv1d(in_channels=8, out_channels=128, kernel_size=(500,), stride=(500,), groups=1, bias=True)
		self.dense_1 = nn.Linear(in_features=128, out_features=128, bias=True)
		self.dense_2 = nn.Linear(in_features=128, out_features=1, bias=True)
		if pretrained_path is not None:
			self.load_simplified_ember_model(pretrained_path)
		if use_cuda:
			self.cuda()

	@classmethod
	def path_to_exe_vector(cls, path, max_length):
		exe = cls.load_sample_from_file(path, max_length, has_shape=True)
		return exe.reshape(max_length)

	@classmethod
	def bytes_to_numpy(cls, bytez, max_length):
		"""
		It creates a numpy array from bare bytes. The vector is max_length long.
		"""
		b = np.ones((max_length,), dtype=np.uint16)*256
		bytez = np.frombuffer(bytez[:max_length], dtype=np.uint8)
		b[:len(bytez)] = bytez
		return np.array(b, dtype=float)

	@classmethod
	def load_sample_from_file(cls, path, max_length, has_shape=False):
		"""
		It creates a numpy array containing a sample. The vector is max_length long.
		If shape is true, then the path is supposed to be a (1,1) matrix.
		Hence, item() is called.
		"""
		file_path = path.item() if has_shape else path
		with open(file_path, 'rb') as malware:
			code = cls.bytes_to_numpy(malware.read(), max_length)
		return code

	def embed(self, input_x, transpose=True):
		"""
		It embeds an input vector into MalConv embedded representation.
		"""
		if isinstance(input_x, torch.Tensor):
			x = input_x.type(torch.LongTensor)
		else:
			x = torch.autograd.Variable(torch.from_numpy(input_x).type(torch.LongTensor))
		x = x.squeeze(dim=1)
		if use_cuda:
			x = x.cuda()
		emb_x = self.embedding_1(x)
		if transpose:
			emb_x = torch.transpose(emb_x, 1, 2)
		return emb_x

	def compute_embedding_gradient(self, numpy_x):
		"""
		It computes the gradient w.r.t. the embedding layer.
		"""
		emb_x = self.embed(numpy_x)
		y = self._emb_forward(emb_x)
		g = torch.autograd.grad(y, emb_x)[0]
		g = torch.transpose(g, 1, 2)[0]
		return g

	def _emb_forward(self, x):
		conv1d_1 = self.conv1d_1(x)
		conv1d_2 = self.conv1d_2(x)
		conv1d_1_activation = torch.relu(conv1d_1)
		conv1d_2_activation = torch.sigmoid(conv1d_2)
		multiply_1 = conv1d_1_activation * conv1d_2_activation
		global_max_pooling1d_1 = F.max_pool1d(input=multiply_1, kernel_size=multiply_1.size()[2:])
		global_max_pooling1d_1_flatten = global_max_pooling1d_1.view(global_max_pooling1d_1.size(0), -1)
		dense_1 = self.dense_1(global_max_pooling1d_1_flatten)
		dense_1_activation = torch.relu(dense_1)
		dense_2 = self.dense_2(dense_1_activation)
		dense_2_activation = torch.sigmoid(dense_2)
		return dense_2_activation

	def forward(self, x):
		"""
		Forward pass.
		"""
		embedding_1 = self.embed(x.contiguous())
		output = self._emb_forward(embedding_1)
		return output

	def load_simplified_ember_model(self, path):
		"""
		Load EMBER model.
		Args:
			path {str} : path to model

		"""
		if not isfile(path):
			raise FileNotExistsException('{} path not pointing to regular file!'.format(path))
		f = torch.load(path) if use_cuda else torch.load(path, map_location="cpu")
		self.load_state_dict(f)
		self.eval()


def malconv(**kwargs):
	"""
	Constructs a MalConv model.
	Input must be a tensor / numpy array of size [n, D].
	"""
	return MalConv(**kwargs)


if __name__ == "__main__":
	m = MalConv(pretrained_path='secml_malware/data/trained/pretrained_malconv.pth')
	print(m)
