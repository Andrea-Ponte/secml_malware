import struct
import lief


def shift_pointer_to_section_content(liefpe, raw_code, entry_index, amount):
	pe_position = liefpe.dos_header.addressof_new_exeheader
	optional_header_size = liefpe.header.sizeof_optional_header
	coff_header_size = 24
	section_entry_length = 40
	size_of_raw_data_pointer = 20
	shift = (
		pe_position
		+ coff_header_size
		+ optional_header_size
		+ (entry_index * section_entry_length)
		+ size_of_raw_data_pointer
	)

	old_value = struct.unpack("<I", raw_code[shift : shift + 4])[0]
	new_value = old_value + amount
	new_value = struct.pack("<I", new_value)
	raw_code[shift : shift + 4] = new_value

	return raw_code


def shift_pe_header(liefpe, raw_code, amount):
	pe_position = liefpe.dos_header.addressof_new_exeheader
	raw_code[0x3C:0x40] = struct.pack("<I", pe_position + amount)

	[raw_code.insert(pe_position, 0) for _ in range(amount)]

	return raw_code


def apply_shift(file_name, new_file_name=None, amount=0x200):
	file_path = file_name
	with open(file_path, "rb") as f:
		code = bytearray(f.read())
	return apply_shift_to_raw_code(amount, code, new_file_name)


def apply_shift_to_raw_code(amount, code, new_file_name):
	parse_pe = lief.PE.parse(list(code))
	amount = (
		parse_pe.optional_header.file_alignment if amount is None else amount
	)  # if > altro alignment, crash
	for i, s in enumerate(parse_pe.sections):
		print(f"Shifting {s.name}")
		code = shift_pointer_to_section_content(parse_pe, code, i, amount)
	code = shift_pe_header(parse_pe, code, amount)
	if new_file_name is not None:
		with open(new_file_name, "wb") as f:
			f.write(code)
		print(f"Written {new_file_name}")
	return code
