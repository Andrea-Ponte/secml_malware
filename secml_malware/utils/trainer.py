"""
.. module:: Trainer
	:synopsis: Trainer for a given CClassifier object.

.. moduleauthor:: Luca Demetrio <luca.demetrio@dibris.unige.it>

"""
import os
import torch
import magic
import random
import numpy as np
from secml.data import CDataset
from secml.utils.c_file_manager import folder_exist, listdir
from secml.ml.peval.c_perfevaluator_xval import CPerfEvaluatorXVal
from secml.ml.peval.metrics.c_metric_accuracy import CMetricAccuracy
from secml.ml.classifiers import CClassifier
from secml_malware.utils.exceptions import FolderNotExistsException
from secml.data.splitter import CDataSplitter


class Trainer(object):
	"""
	Trainer for CClassifier classifier.
	"""

	def __init__(self, classifier, loader, classes_dict_path, accepted_signature=None):
		"""
		Constructor of trainer object.

		Parameters
		----------
		classifier
			object of type CClassifier. Raise exception if other object is passed.
		loader
			function with string parameter that read a single sample and returns an array of numbers
		classes_dict_path
			dictionary of labels -> path.
			Key must be label index.

			Example:
			classes_dict_path[0] = <path of samples of class 0>
			classes_dict_path[n] = <path of samples of class n>
		"""
		if not isinstance(classifier, CClassifier):
			raise TypeError(
				"classifier is not CClassifier, but {}".format(type(classifier))
			)
		self.classifier = classifier
		self.loader = loader
		self.accepted_signature = accepted_signature
		if not isinstance(classes_dict_path, dict):
			raise TypeError(
				"classes_dict_path is not dict, but {}".format(type(classes_dict_path))
			)
		for _, folder in classes_dict_path.items():
			if not folder_exist(folder):
				raise FolderNotExistsException("{} is not a folder".format(folder))
		self.classes_dict_path = classes_dict_path

	def _traverse(self, X, y, folder, key):
		for f in listdir(folder):
			path = os.path.join(folder, f)
			if os.path.isfile(path):
				if self.accepted_signature is not None:
					signature = magic.from_file(path)
					contained = [l in signature for l in self.accepted_signature]
					if not any(contained):
						continue
				# x = self.loader(path)
				X.append(path)
				y.append(key)
			elif os.path.isdir(path):
				self._traverse(X, y, path, key)

	def create_dataset(
		self, tensor_type=torch.Tensor, limit_per_class=None, random_sample=None
	):
		"""
		Creates CDataset for classification purpouses, applying the transformation needed for loading.
		------
		!NB:
		!this apporach may be memory consuming. Use create_dataset_path_no_transform to store only the pah and pass a transformer function to the model.
		Returns
		-------
		CDataset
		"""
		X, y = [], []
		for key, folder in self.classes_dict_path.items():
			X_t, y_t = [], []
			self._traverse(X_t, y_t, folder, key)
			if limit_per_class is not None:
				lower_bound = min(limit_per_class, len(X_t))
				if random_sample:
					X_t = random.sample(X_t, lower_bound)
					y_t = random.sample(y_t, lower_bound)
				else:
					X_t = X_t[:lower_bound]
					y_t = y_t[:lower_bound]
			X.extend([self.loader(x) for x in X_t])
			y.extend(y_t)
		X = tensor_type(X)
		return CDataset(X, y)

	def create_dataset_path_no_transform(
		self, shape=False, limit_per_class=None, random_sample=None
	):
		"""
		Creates CDataset for classification purpouses, by extracting the path where the fles are contained.

		Returns
		-------
		CDataset
		"""
		X, y = [], []
		for key, folder in self.classes_dict_path.items():
			X_t, y_t = [], []
			self._traverse(X_t, y_t, folder, key)
			if limit_per_class is not None:
				lower_bound = min(limit_per_class, len(X_t))
				if random_sample:
					X_t = random.sample(X_t, lower_bound)
					y_t = random.sample(y_t, lower_bound)
				else:
					X_t = X_t[:lower_bound]
					y_t = y_t[:lower_bound]
			X.extend(X_t)
			y.extend(y_t)
		if shape:
			X = np.array(X)
			X = X.reshape((len(X), 1))
		return CDataset(X, y)

	def create_surrogate_dataset_using_classifier(self, classifier):
		"""
		Creates CDataset of goodware and malware samples by querying the input classifier.

		Parameters
		----------
		classifier
			trained CClassifier model, must be CClassifierclassifierPyTorch
		Returns
		-------
		CDataset
		"""
		if not isinstance(classifier, CClassifier):
			raise TypeError(
				"classifier is not CClassifier, but {}".format(type(classifier))
			)
		dataset = self.create_dataset()
		y_pred = classifier.predict(dataset.X)
		dataset.Y = y_pred
		return dataset

	def train_regular_classifier(
		self, output_state_path=None, dataset=None, return_mean_error=False, n_fold=5
	):
		"""
		Main function for training the input model.

		Parameters
		----------
		output_state_path
			if string, it will be used for saving the trained model parameters.

		Returns
		-------
		CClassifier
			trained model
		"""
		if dataset is None:
			dataset = self.create_dataset()
		elif not isinstance(dataset, CDataset):
			raise TypeError(
				"input dataset is not CDataset but {}".format(type(dataset))
			)
		if not isinstance(output_state_path, str):
			raise TypeError(
				"output_state_path is not string, but {}".format(
					type(output_state_path)
				)
			)
		if n_fold is not None:
			xval_splitter = CDataSplitter.create(
				"strat-kfold", num_folds=n_fold, random_state=50000
			)
			xval_splitter.compute_indices(dataset)
			metric = CMetricAccuracy()
			xval = CPerfEvaluatorXVal(xval_splitter, metric)
			mean_error = xval.compute_performance(self.classifier, dataset)
		else:
			self.classifier = self.classifier.fit(dataset)
			mean_error = 1 - self.classifier._best_acc
		if output_state_path is not None:
			state_dict = self.classifier.state_dict()
			torch.save(state_dict, output_state_path)
		if return_mean_error:
			return self.classifier, mean_error
		return self.classifier
